<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Combo Trainer</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background-color: #f9f9f9;
      margin: 0;
      padding: 1rem;
    }

    h1 {
      text-align: center;
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }

    .combo-toggle-container {
      margin-bottom: 1rem;
      text-align: center;
    }

    #toggleCombosBtn {
      background-color: #ccc;
      color: #333;
      border: none;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 0.5rem;
    }

    #toggleCombosBtn:hover {
      background-color: #bbb;
    }

    .controls {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    .controls label {
      font-size: 0.9rem;
    }

    .controls input,
    .controls select {
      padding: 0.2rem;
      font-size: 1rem;
    }

    .lists {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-x: auto;
    }

    .lists.collapsed {
      display: none;
    }

    .list-container {
      background: #fff;
      border-radius: 8px;
      padding: 0.5rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      width: 100%;
    }

    .list-container h2 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
      text-align: center;
    }

    #masterLists .list-container {
  background: #fff3e0; /* soft orange tone */
  border: 2px dashed #ff9800; /* orange border */
  box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2);
}

   #masterLists .list-container h2 {
  background-color: #fb8c00;
  color: white;
  padding: 0.5rem;
  border-radius: 8px;
  font-style: italic;
  font-weight: bold;
  letter-spacing: 0.5px;
}

    .rounds .list-container {
      background: #E8F5E9;
    }

    .rounds .list-container h2 {
      background-color: #81C784;
      color: white;
      padding: 0.5rem;
      border-radius: 8px;
    }

    .rounds {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }

    li {
      padding: 0.5rem 0.75rem;
      background: #eee;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      flex: 0 1 auto;
      text-align: center;
    }

    li.highlight {
      background-color: #ffd54f;
      font-weight: bold;
    }

    .round-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      margin-top: 1rem;
    }

    button {
      padding: 0.6rem 1rem;
      font-size: 1rem;
      border: none;
      border-radius: 6px;
      background-color: #007AFF;
      color: white;
      cursor: pointer;
    }

    button:hover {
      background-color: #005FCC;
    }

#stopButton {
  background-color: #d32f2f;
  font-size: 1.5rem;
  padding: 0.5rem 1rem;
  border-radius: 50%;
  width: 3rem;
  height: 3rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

#stopButton:hover {
  background-color: #b71c1c;
}


    #comboDisplay {
      font-size: 1.5rem;
      text-align: center;
      margin: 1rem auto 0.5rem;
      background: #fff;
      border: 1px solid #ccc;
      padding: 1rem;
      border-radius: 10px;
      max-width: 90%;
    }

#timerDisplay {
  font-family: 'Courier New', Courier, monospace;
  font-size: 3rem;
  text-align: center;
  font-weight: bold;
  margin-top: 1rem;
  background: black;
  color: yellow;
  padding: 0rem;
  border-radius: 12px;
  max-width: 300px;
  margin-left: auto;
  margin-right: auto;
  box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
}
#fullscreenOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: black;
  color: yellow;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
  flex-direction: column;
  text-align: center;
}

#fullscreenContent {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#fullscreenTimer {
  font-size: 20vw;
  font-family: 'Courier New', Courier, monospace;
  margin-bottom: 2vh;
  line-height: 1;
  max-width: 100%;
  word-wrap: break-word;
}

#fullscreenCombo {
  font-size: 8vw;
  font-weight: bold;
  max-width: 90vw;
  word-wrap: break-word;
}


    .round-settings {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: center;
      margin-bottom: 15px;
      font-family: sans-serif;
      font-size: 14px;
    }

    .round-settings label {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-weight: bold;
    }

    .round-settings input {
      margin-top: 5px;
      padding: 6px;
      width: 100px;
      font-size: 14px;
    }

    .preset-section {
      background-color: #fff;
      padding: 1rem;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      margin-top: 20px;
      text-align: center;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .preset-section h2 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #007AFF;
    }

    .preset-controls {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
    }

    .input-group input,
    .input-group select {
      width: 100%;
      max-width: 260px;
      padding: 8px;
      font-size: 0.95rem;
      border-radius: 6px;
      border: 1px solid #ccc;
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

.save-btn,
.load-btn,
.edit-btn,
.delete-btn {
  padding: 5px 10px;
  font-size: 0.85rem;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  min-width: 60px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}


    .save-btn {
      background-color: #4CAF50;
      color: white;
    }

    .load-btn {
      background-color: #007AFF;
      color: white;
    }

    .edit-btn {
      background-color: #FFA726;
      color: white;
    }

    .delete-btn {
      background-color: #E53935;
      color: white;
    }

    .save-btn:hover {
      background-color: #45a049;
    }

    .load-btn:hover {
      background-color: #005FCC;
    }

    .edit-btn:hover {
      background-color: #FB8C00;
    }

    .delete-btn:hover {
      background-color: #C62828;
    }

    @media (max-width: 500px) {
      .button-group {
        flex-direction: column;
        gap: 6px;
        width: 100%;
      }

      .save-btn,
      .load-btn,
      .edit-btn,
      .delete-btn {
        width: 100%;
      }
    }

    @media (min-width: 768px) {
      .lists {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }

      .list-container {
        width: 300px;
      }

      .rounds {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
      }

      .list-container ul {
        justify-content: flex-start;
      }
    }
	
	.rounds .round-selected {
  outline: 3px solid #007AFF;
  box-shadow: 0 0 10px rgba(0, 122, 255, 0.5);
}
#fullscreenRound {
  font-size: 2rem;
  color: #00d4ff;
  margin-bottom: 0.5rem;
}

#fullscreenPlayer {
  font-size: 2rem;
  color: #ff4081;
  margin-bottom: 1.5rem;
}

  </style>
</head>
<body>
  <h1>Combo Trainer</h1>

 <div class="combo-toggle-container">
  <button id="toggleCombosBtn" onclick="toggleComboList()">Show Combo List ▼</button>
  <div class="lists collapsed" id="masterLists"></div>
</div>
<div style="text-align:center; margin-top: 1rem;">
  <button onclick="addRound()">+ </button>
  <button onclick="removeLastRound()">-</button>
</div>

  <div class="rounds">
    <div class="list-container">
      <h2>Round 1</h2>
      <ul id="round1"></ul>
    </div>
    <div class="list-container">
      <h2>Round 2</h2>
      <ul id="round2"></ul>
    </div>
    <div class="list-container">
      <h2>Round 3</h2>
      <ul id="round3"></ul>
    </div>
  </div>

  <div id="timerDisplay">1:00</div>
  <div id="comboDisplay">Ready</div>
  <div class="round-settings">
    <label>
      Round Time (seconds):
      <input type="number" id="roundTimeInput" value="60" min="10" step="10">
    </label>
    <label>
      Rest Time (seconds):
      <input type="number" id="restTimeInput" value="10" min="5" step="5">
    </label>
  </div>


  <div class="controls">
    <label>
      Callout Speed:
      <select id="intervalMode" onchange="toggleIntervalInputs()">
        <option value="random">Random</option>
        <option value="slow">Slow</option>
        <option value="medium" selected>Medium</option>
        <option value="fast">Fast</option>
      </select>
    </label>
    <label id="minLabel">Min(s):
      <input type="number" id="minInterval" value="2" min="1" max="20">
    </label>
    <label id="maxLabel">Max(s):
      <input type="number" id="maxInterval" value="4" min="1" max="20">
    </label>
  </div>

<div class="round-buttons">
  <div style="display: flex; gap: 0.5rem; justify-content: center;">
    <button onclick="startAllRounds(false)">1-Player</button>
    <button onclick="startAllRounds(true)">2-Player</button>
  </div>
  <div style="margin-top: 0.5rem; text-align: center;">
    <button id="stopButton" onclick="stopCombo()">⏹</button>
  </div>
</div>



  <details class="preset-section">
  <summary><strong>Save & Load Presets</strong></summary>
  <div class="preset-controls" style="margin-top: 1rem;">
    <div class="input-group">
      <button class="save-btn" onclick="saveSetup()">Save</button>
    </div>
    <div class="input-group">
      <select id="savedSetups">
        <option value="">-- Select a setup --</option>
      </select>
      <div class="button-group">
        <button class="load-btn" onclick="loadSetup()">Load</button>
        <button class="edit-btn" onclick="editSetup()">Rename</button>
        <button class="delete-btn" onclick="deleteSetup()">Delete</button>
      </div>
    </div>
  </div>
</details>

<div style="text-align: center; margin-top: 1rem;">
  <a href="boxernome3.html" style="text-decoration: none;">
    <button style="background-color: #6a1b9a; color: white; padding: 0.6rem 1.2rem; font-size: 1rem; border-radius: 6px; border: none; cursor: pointer;">
      Open Boxernome
    </button>
  </a>
</div>

  <script>
  
let audioContext;

function getAudioContext() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  return audioContext;
}

    let intervalId = null;
    let timerInterval = null;
    let selectedVoice = null;
    let activeRoundId = null;
	let initialTimeoutId = null;

    const roundDuration = 60;

    const defaultCombos = [
"1", "2", "3", "4", "1B", "2B", "3B", "4B",
 
"1-2", "2-3", "1-1", "1-4", "1-4B", "1B-4", "1-2B", "2-2", "2-2B", "2-3B", "2B-3", "3-4",

 "1-2-3", "1-1-2", "1-2-1", "2-3-2", "1-2B-3", "2-3B-2", "2-3B-3",  "2-1-2B", "1-2-3B",

"1-2-3B-2", "1-2-1-2", "1-1-2B-3", "1-2-1-4", "2-3B-2-3",

 "1-2B-3-S-2-3B"
    ];

    const speakMap = {
      "S": "SLIP", "P": "PARRY", "D": "DUCK", "SB": "STEP BACK"
    };


function getAudioContext() {
  if (!window._audioCtx) {
    window._audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return window._audioCtx;
}

function playBellSound() {
  const ctx = getAudioContext();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = 'sine';
  osc.frequency.setValueAtTime(1000, ctx.currentTime);
  gain.gain.setValueAtTime(1, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start();
  osc.stop(ctx.currentTime + 1.2);
}

function playTenSecondTone() {
  const ctx = getAudioContext();
  const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.05, ctx.sampleRate);
  const data = buffer.getChannelData(0);

  // Fill with white noise
  for (let i = 0; i < data.length; i++) {
    data[i] = Math.random() * 2 - 1;
  }

  function playCrack(delay) {
    // Noise burst
    const noiseSource = ctx.createBufferSource();
    noiseSource.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = "highpass";
    noiseFilter.frequency.setValueAtTime(800, ctx.currentTime + delay);

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(1.1, ctx.currentTime + delay);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + 0.04);

    noiseSource.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(ctx.destination);

    noiseSource.start(ctx.currentTime + delay);

    // Tonal blip (very short)
    const tone = ctx.createOscillator();
    tone.type = "square"; // gives a woody click
    tone.frequency.setValueAtTime(500, ctx.currentTime + delay); // subtle low body

    const toneGain = ctx.createGain();
    toneGain.gain.setValueAtTime(0.4, ctx.currentTime + delay);
    toneGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + 0.05);

    tone.connect(toneGain);
    toneGain.connect(ctx.destination);

    tone.start(ctx.currentTime + delay);
    tone.stop(ctx.currentTime + delay + 0.05);
  }

  playCrack(0);
  playCrack(0.20);
  playCrack(0.40);
}


function playCountdownBeep() {
  const ctx = getAudioContext();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "square";
  osc.frequency.setValueAtTime(1000, ctx.currentTime); // Higher pitch
  gain.gain.setValueAtTime(1, ctx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);

  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.2);
}



function setActiveRound(roundId) {
  activeRoundId = roundId;
  document.querySelectorAll(".rounds .list-container").forEach(container => {
    const ul = container.querySelector("ul");
    container.classList.toggle("round-selected", ul && ul.id === roundId);
  });
  highlightMasterCombos();
}


    function highlightMasterCombos() {
      const activeCombos = Array.from(document.getElementById(activeRoundId)?.children || []).map(li => li.textContent);
      document.querySelectorAll("#masterLists li").forEach(li => {
        if (activeCombos.includes(li.textContent)) {
          li.classList.add("highlight");
        } else {
          li.classList.remove("highlight");
        }
      });
    }

    function groupCombosByPunchCount(combos) {
      const groups = {
        "1 Punch": [],
        "2 Punch": [],
        "3 Punch": [],
        "4 Punch": [],
        "5+ Punch": []
      };

      combos.forEach(combo => {
        const count = combo.split('-').length;
        if (count === 1) groups["1 Punch"].push(combo);
        else if (count === 2) groups["2 Punch"].push(combo);
        else if (count === 3) groups["3 Punch"].push(combo);
        else if (count === 4) groups["4 Punch"].push(combo);
        else groups["5+ Punch"].push(combo);
      });

      return groups;
    }

    function renderMasterLists() {
      const grouped = groupCombosByPunchCount(defaultCombos);
      const container = document.getElementById("masterLists");
      container.innerHTML = '';

      for (const section in grouped) {
        const div = document.createElement("div");
        div.className = "list-container";
        div.innerHTML = `<h2>${section}</h2>`;
        const ul = document.createElement("ul");

        grouped[section].forEach(combo => {
          const li = document.createElement("li");
          li.textContent = combo;
          li.addEventListener("click", () => toggleComboInActiveRound(combo));

          ul.appendChild(li);
        });

        div.appendChild(ul);
        container.appendChild(div);
      }
    }

function toggleComboInActiveRound(combo) {
  if (!activeRoundId) {
    alert("Please select a round first.");
    return;
  }

  const ul = document.getElementById(activeRoundId);

  // Remove freestyle message if adding a real combo
  const freestyle = ul.querySelector(".freestyle-placeholder");
  if (freestyle) freestyle.remove();

  const existing = Array.from(ul.children).find(li => li.textContent === combo);

 if (existing) {
  existing.remove();
  checkFreestylePlaceholder(ul); // ✅ Add this here to handle master list removal
} else {
  const li = document.createElement("li");
  li.textContent = combo;
  li.addEventListener("click", () => {
    li.remove();
    checkFreestylePlaceholder(ul);
  });
  ul.appendChild(li);
}


  highlightMasterCombos();
}
function checkFreestylePlaceholder(ul) {
  if (ul.children.length === 0) {
    const placeholder = document.createElement("li");
    placeholder.textContent = "Freestyle Round";
    placeholder.classList.add("freestyle-placeholder");
    ul.appendChild(placeholder);
  }
}


    function showRoundChoice(combo) {
      const div = document.createElement("div");
      div.style.position = "fixed";
      div.style.top = "50%";
      div.style.left = "50%";
      div.style.transform = "translate(-50%, -50%)";
      div.style.background = "#fff";
      div.style.padding = "1rem";
      div.style.border = "2px solid #ccc";
      div.style.borderRadius = "10px";
      div.style.zIndex = "9999";
      div.style.textAlign = "center";
      div.innerHTML = `
        <p>Add "${combo}" to:</p>
        <button onclick="addToRound('${combo}', 'round1'); this.parentElement.remove()">Round 1</button>
        <button onclick="addToRound('${combo}', 'round2'); this.parentElement.remove()">Round 2</button>
        <button onclick="addToRound('${combo}', 'round3'); this.parentElement.remove()">Round 3</button>
        <br><br>
        <button onclick="this.parentElement.remove()">Cancel</button>
      `;
      document.body.appendChild(div);
    }

    function addToRound(combo, roundId) {
      const ul = document.getElementById(roundId);
      const li = document.createElement("li");
      li.textContent = combo;
      li.addEventListener("click", () => {
  li.remove();
  checkFreestylePlaceholder(ul);
});

      ul.appendChild(li);
      highlightMasterCombos();
    }

function speakCombo(combo, callback) {
  const display = document.getElementById("comboDisplay");
  const fsDisplay = document.getElementById("fullscreenCombo");

  display.textContent = combo;
  if (isOverlayVisible && fsDisplay) {
    fsDisplay.textContent = combo;
  }

  const modCombo = combo.replace(/(\d)-?B/g, "$1-BODY");
  const parts = modCombo.split("-").map(part => speakMap[part] || part);

  const utterance = new SpeechSynthesisUtterance(parts.join(" "));
  utterance.rate = 1;
  if (selectedVoice) utterance.voice = selectedVoice;

  utterance.onend = callback;
  speechSynthesis.speak(utterance);
}

function startAllRounds(isTwoPlayerMode = false) {
  const ctx = getAudioContext();
  if (ctx.state === 'suspended') {
    ctx.resume().catch(e => console.warn('AudioContext resume failed:', e));
  }
  stopCombo();
  const roundIds = Array.from(document.querySelectorAll(".rounds ul")).map(ul => ul.id);

  let currentRound = 0;
  let repeatFlag = false;

  function runNext() {
    if (currentRound >= roundIds.length) {
      document.getElementById("comboDisplay").textContent = "All rounds complete!";
	  
      return;
    }

    const roundId = roundIds[currentRound];
    const combos = Array.from(document.getElementById(roundId).children).map(li => li.textContent);
    const roundDuration = parseInt(document.getElementById("roundTimeInput").value, 10);
    let timeLeft = roundDuration;
    const roundNumber = currentRound + 1;
if (isOverlayVisible) {
  document.getElementById("fullscreenRound").textContent = `Round ${roundNumber}`;
  document.getElementById("fullscreenPlayer").textContent = isTwoPlayerMode && repeatFlag ? "Player 2" : "Player 1";
}

    setActiveRound(roundId);
    document.getElementById("timerDisplay").textContent = formatTime(timeLeft);
document.getElementById("fullscreenTimer").style.color = "yellow";

    const announceRound = new SpeechSynthesisUtterance(`Round ${roundNumber}`);
    if (selectedVoice) announceRound.voice = selectedVoice;
    speechSynthesis.speak(announceRound);

    const isFreestyle = combos.length === 0 || combos.every(c => c.trim().toLowerCase() === "freestyle round");
if (isFreestyle) {
  const msg = "Freestyle Round!!";
  document.getElementById("comboDisplay").textContent = msg;

  if (isOverlayVisible) {
    document.getElementById("fullscreenCombo").textContent = msg;
  }

  const freestyleUtterance = new SpeechSynthesisUtterance("Freestyle Round");
  if (selectedVoice) freestyleUtterance.voice = selectedVoice;
  speechSynthesis.speak(freestyleUtterance);
} else {
  const msg = `Round ${roundNumber}`;
  document.getElementById("comboDisplay").textContent = msg;

  if (isOverlayVisible) {
    document.getElementById("fullscreenCombo").textContent = msg;
  }

  const mode = document.getElementById("intervalMode").value;
  const min = parseFloat(document.getElementById("minInterval").value) * 1000;
  const max = parseFloat(document.getElementById("maxInterval").value) * 1000;

  function getInterval() {
    switch (mode) {
      case "slow": return 4000;
      case "medium": return 2500;
      case "fast": return 1500;
      case "random": return Math.random() * (max - min) + min;
      default: return 2500;
    }
  }

  function nextCall() {
    if (timeLeft <= 0) return;
    const combo = combos[Math.floor(Math.random() * combos.length)];
    speakCombo(combo, () => {
      const delay = getInterval();
      intervalId = setTimeout(nextCall, delay);
    });
  }

  initialTimeoutId = setTimeout(() => {
    nextCall();
  }, 3000);
}

    timerInterval = setInterval(() => {
      timeLeft--;

      if (timeLeft === 10) playTenSecondTone();
      if ([3, 2, 1].includes(timeLeft)) playCountdownBeep();

      document.getElementById("timerDisplay").textContent = formatTime(timeLeft);

if (timeLeft <= 0) {
  clearInterval(timerInterval);
  clearTimeout(intervalId);
  speechSynthesis.cancel();

  if (isTwoPlayerMode && !repeatFlag) {
    repeatFlag = true;
    if (isOverlayVisible) {
      document.getElementById("fullscreenPlayer").textContent = "Player 2";
    }
    startRest();
  } else {
    repeatFlag = false;
    currentRound++;
    if (isOverlayVisible) {
      document.getElementById("fullscreenPlayer").textContent = "Player 1";
    }
    startRest();
  }
}

    }, 1000);
  }

function startRest() {
  let restTime = parseInt(document.getElementById("restTimeInput").value, 10);
  document.getElementById("comboDisplay").textContent = "Rest";
  document.getElementById("timerDisplay").textContent = formatTime(restTime);
  document.getElementById("fullscreenTimer").style.color = "lime";
document.getElementById("timerDisplay").style.color = "lime";



  const restAnnounce = new SpeechSynthesisUtterance(`Rest for ${restTime} seconds`);
  if (selectedVoice) restAnnounce.voice = selectedVoice;
  speechSynthesis.speak(restAnnounce);

  timerInterval = setInterval(() => {
    restTime--;

    // Always update the display first
    document.getElementById("timerDisplay").textContent = formatTime(restTime);

    // Play countdown beeps at 3, 2, 1
if ([3, 2, 1].includes(restTime)) {
  try {
    playCountdownBeep();
  } catch (e) {
    console.error("Rest countdown beep error:", e);
  }
}


    if (restTime <= 0) {
      clearInterval(timerInterval);
      runNext();
    }
  }, 1000);
}


  runNext();
}




function stopCombo() {
  clearTimeout(initialTimeoutId);
  clearTimeout(intervalId);
  clearInterval(timerInterval);
  speechSynthesis.cancel();

  const defaultTime = parseInt(document.getElementById("roundTimeInput").value, 10);
  document.getElementById("timerDisplay").textContent = formatTime(defaultTime);
  document.getElementById("comboDisplay").textContent = "Paused";
}


    function toggleIntervalInputs() {
      const isRandom = document.getElementById("intervalMode").value === "random";
      document.getElementById("minLabel").style.display = isRandom ? "inline-block" : "none";
      document.getElementById("maxLabel").style.display = isRandom ? "inline-block" : "none";
    }

function setMaleVoice() {
  const voices = speechSynthesis.getVoices();

  // If no voices are available yet, try again shortly
  if (voices.length === 0) {
    setTimeout(setMaleVoice, 200);
    return;
  }

  // Prioritize realistic male voices
  selectedVoice = voices.find(v => /daniel|evan|alex|aaron/i.test(v.name)) || voices.find(v => /en/i.test(v.lang));
  console.log("Selected voice:", selectedVoice?.name);
}

// Make sure this runs after voices load (iOS-specific issue)
if (typeof speechSynthesis.onvoiceschanged !== "undefined") {
  speechSynthesis.onvoiceschanged = setMaleVoice;
}

// Also call it once on load to catch browsers that already loaded voices
setMaleVoice();

// Resume AudioContext on first user click (iOS fix for oscillator/tone sounds)
document.body.addEventListener('click', () => {
  const ctx = getAudioContext();
  if (ctx.state === 'suspended') {
    ctx.resume().then(() => {
      console.log('AudioContext resumed');
    }).catch(err => {
      console.error('AudioContext resume failed:', err);
    });
  }
}, { once: true });


function formatTime(seconds) {
  const m = Math.floor(seconds / 60).toString();
  const s = (seconds % 60).toString().padStart(2, '0');
  const formatted = `${m}:${s}`;

  if (isOverlayVisible) {
    const fsTimer = document.getElementById("fullscreenTimer");
    if (fsTimer) fsTimer.textContent = formatted;
  }

  return formatted;
}
	

function saveSetup() {
  const currentSelection = document.getElementById("savedSetups").value;
  const name = prompt("Enter a name for this setup:", currentSelection || "");
  if (!name) return alert("Save cancelled. No name entered.");

  const roundElements = Array.from(document.querySelectorAll(".rounds ul"));
  const rounds = {};
  roundElements.forEach(ul => {
    rounds[ul.id] = Array.from(ul.children).map(li => li.textContent);
  });

  const setup = {
    rounds,
    roundCount: roundCounter, // <-- Save round count
    intervalMode: document.getElementById("intervalMode").value,
    minInterval: document.getElementById("minInterval").value,
    maxInterval: document.getElementById("maxInterval").value,
    roundTime: document.getElementById("roundTimeInput").value,
    restTime: document.getElementById("restTimeInput").value
  };

  localStorage.setItem(`comboSetup:${name}`, JSON.stringify(setup));
  updateSavedSetups();
  alert(`Saved setup: ${name}`);
}


function deleteSetup() {
  const name = document.getElementById("savedSetups").value;
  if (!name) return alert("Please select a setup to delete.");
  const confirmDelete = confirm(`Are you sure you want to delete "${name}"?`);
  if (confirmDelete) {
    localStorage.removeItem(`comboSetup:${name}`);
    updateSavedSetups();
    alert(`Deleted setup: ${name}`);
  }
}

function editSetup() {
  const oldName = document.getElementById("savedSetups").value;
  if (!oldName) return alert("Please select a setup to rename.");
  const newName = prompt("Enter a new name for this setup:", oldName);
  if (!newName || newName === oldName) return;

  const existingData = localStorage.getItem(`comboSetup:${oldName}`);
  if (!existingData) return alert("Original setup not found.");

  localStorage.setItem(`comboSetup:${newName}`, existingData);
  localStorage.removeItem(`comboSetup:${oldName}`);
  updateSavedSetups();
  alert(`Renamed "${oldName}" to "${newName}"`);
}

function loadSetup() {
  const name = document.getElementById("savedSetups").value;
  if (!name) return;

  const data = localStorage.getItem(`comboSetup:${name}`);
  if (!data) return alert("No saved data found.");
  const setup = JSON.parse(data);

  // Remove extra rounds if needed
  const existing = document.querySelectorAll(".rounds .list-container").length;
  for (let i = existing; i > 3; i--) removeLastRound();
  while (roundCounter < (setup.roundCount || 3)) {
    addRound();
  }

  // Load round combos
  Object.keys(setup.rounds || {}).forEach(id => {
    const ul = document.getElementById(id);
    if (!ul) return;
   ul.innerHTML = '';

(setup.rounds[id] || []).forEach(combo => {
  const li = document.createElement("li");
  li.textContent = combo;
  li.addEventListener("click", () => {
    li.remove();
    checkFreestylePlaceholder(ul);
  });
  ul.appendChild(li);
});

checkFreestylePlaceholder(ul); // ✅ Only check after loading combos

  });

  document.getElementById("intervalMode").value = setup.intervalMode || "medium";
  toggleIntervalInputs(); // 🔧 Fix visibility of min/max for random mode

  document.getElementById("minInterval").value = setup.minInterval || 2;
  document.getElementById("maxInterval").value = setup.maxInterval || 4;
  document.getElementById("roundTimeInput").value = setup.roundTime || 60;
  document.getElementById("restTimeInput").value = setup.restTime || 10;
  document.getElementById("savedSetups").value = name;

  highlightMasterCombos();
}


function updateSavedSetups() {
  const select = document.getElementById("savedSetups");
  select.innerHTML = `<option value="">-- Select a setup --</option>`;

  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key.startsWith("comboSetup:")) {
      const name = key.replace("comboSetup:", "");
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      select.appendChild(option);
    }
  }
}

document.addEventListener("DOMContentLoaded", () => {
  renderMasterLists();
  updateSavedSetups();
  setMaleVoice();
  toggleIntervalInputs();
  window.speechSynthesis.getVoices();

  document.querySelectorAll(".rounds .list-container").forEach(container => {
    const ul = container.querySelector("ul");
    if (ul) {
      checkFreestylePlaceholder(ul);  // <-- 🔥 Add this line
      container.addEventListener("click", () => setActiveRound(ul.id));
    }
  });
});

  // Initialize dropdown on page load


function toggleComboList() {
  const comboList = document.getElementById("masterLists");
  const button = document.getElementById("toggleCombosBtn");

  comboList.classList.toggle("collapsed");

  if (comboList.classList.contains("collapsed")) {
    button.textContent = "Show Combo List ▼";
  } else {
    button.textContent = "Hide Combo List ▲";
  }
}
let roundCounter = 3;

function addRound() {
  roundCounter++;
  const roundId = `round${roundCounter}`;

  const container = document.createElement("div");
  container.className = "list-container";
  container.innerHTML = `<h2>Round ${roundCounter}</h2><ul id="${roundId}"></ul>`;

  container.addEventListener("click", () => setActiveRound(roundId));

  document.querySelector(".rounds").appendChild(container);

  // Add freestyle placeholder
  checkFreestylePlaceholder(container.querySelector("ul"));
}


function removeLastRound() {
  if (roundCounter <= 3) return alert("Can't remove the default 3 rounds.");

  const container = document.querySelector(".rounds").lastElementChild;
  if (container) container.remove();
  roundCounter--;
}
let isOverlayVisible = false;

function toggleOverlay() {
  const overlay = document.getElementById("fullscreenOverlay");
  isOverlayVisible = !isOverlayVisible;
  overlay.style.display = isOverlayVisible ? "flex" : "none";
}

document.getElementById("timerDisplay").addEventListener("click", toggleOverlay);

  </script>
 
<div id="fullscreenOverlay" onclick="toggleOverlay()" style="display:none;">
  <div id="fullscreenContent">
    <div id="fullscreenRound">Round 1</div>
    <div id="fullscreenPlayer">Player 1</div>
    <div id="fullscreenTimer">1:00</div>
    <div id="fullscreenCombo">Ready</div>
  </div>
</div>



</body>
</html>
